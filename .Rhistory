""
}
renv_bootstrap_platform_prefix_auto <- function() {
prefix <- tryCatch(renv_bootstrap_platform_os(), error = identity)
if (inherits(prefix, "error") || prefix %in% "unknown") {
msg <- paste(
"failed to infer current operating system",
"please file a bug report at https://github.com/rstudio/renv/issues",
sep = "; "
)
warning(msg)
}
prefix
}
renv_bootstrap_platform_os <- function() {
sysinfo <- Sys.info()
sysname <- sysinfo[["sysname"]]
# handle Windows + macOS up front
if (sysname == "Windows")
return("windows")
else if (sysname == "Darwin")
return("macos")
# check for os-release files
for (file in c("/etc/os-release", "/usr/lib/os-release"))
if (file.exists(file))
return(renv_bootstrap_platform_os_via_os_release(file, sysinfo))
# check for redhat-release files
if (file.exists("/etc/redhat-release"))
return(renv_bootstrap_platform_os_via_redhat_release())
"unknown"
}
renv_bootstrap_platform_os_via_os_release <- function(file, sysinfo) {
# read /etc/os-release
release <- utils::read.table(
file             = file,
sep              = "=",
quote            = c("\"", "'"),
col.names        = c("Key", "Value"),
comment.char     = "#",
stringsAsFactors = FALSE
)
vars <- as.list(release$Value)
names(vars) <- release$Key
# get os name
os <- tolower(sysinfo[["sysname"]])
# read id
id <- "unknown"
for (field in c("ID", "ID_LIKE")) {
if (field %in% names(vars) && nzchar(vars[[field]])) {
id <- vars[[field]]
break
}
}
# read version
version <- "unknown"
for (field in c("UBUNTU_CODENAME", "VERSION_CODENAME", "VERSION_ID", "BUILD_ID")) {
if (field %in% names(vars) && nzchar(vars[[field]])) {
version <- vars[[field]]
break
}
}
# join together
paste(c(os, id, version), collapse = "-")
}
renv_bootstrap_platform_os_via_redhat_release <- function() {
# read /etc/redhat-release
contents <- readLines("/etc/redhat-release", warn = FALSE)
# infer id
id <- if (grepl("centos", contents, ignore.case = TRUE))
"centos"
else if (grepl("redhat", contents, ignore.case = TRUE))
"redhat"
else
"unknown"
# try to find a version component (very hacky)
version <- "unknown"
parts <- strsplit(contents, "[[:space:]]")[[1L]]
for (part in parts) {
nv <- tryCatch(numeric_version(part), error = identity)
if (inherits(nv, "error"))
next
version <- nv[1, 1]
break
}
paste(c("linux", id, version), collapse = "-")
}
renv_bootstrap_library_root_name <- function(project) {
# use project name as-is if requested
asis <- Sys.getenv("RENV_PATHS_LIBRARY_ROOT_ASIS", unset = "FALSE")
if (asis)
return(basename(project))
# otherwise, disambiguate based on project's path
id <- substring(renv_bootstrap_hash_text(project), 1L, 8L)
paste(basename(project), id, sep = "-")
}
renv_bootstrap_library_root <- function(project) {
prefix <- renv_bootstrap_profile_prefix()
path <- Sys.getenv("RENV_PATHS_LIBRARY", unset = NA)
if (!is.na(path))
return(paste(c(path, prefix), collapse = "/"))
path <- renv_bootstrap_library_root_impl(project)
if (!is.null(path)) {
name <- renv_bootstrap_library_root_name(project)
return(paste(c(path, prefix, name), collapse = "/"))
}
renv_bootstrap_paths_renv("library", project = project)
}
renv_bootstrap_library_root_impl <- function(project) {
root <- Sys.getenv("RENV_PATHS_LIBRARY_ROOT", unset = NA)
if (!is.na(root))
return(root)
type <- renv_bootstrap_project_type(project)
if (identical(type, "package")) {
userdir <- renv_bootstrap_user_dir()
return(file.path(userdir, "library"))
}
}
renv_bootstrap_validate_version <- function(version, description = NULL) {
# resolve description file
#
# avoid passing lib.loc to `packageDescription()` below, since R will
# use the loaded version of the package by default anyhow. note that
# this function should only be called after 'renv' is loaded
# https://github.com/rstudio/renv/issues/1625
description <- description %||% packageDescription("renv")
# check whether requested version 'version' matches loaded version of renv
sha <- attr(version, "sha", exact = TRUE)
valid <- if (!is.null(sha))
renv_bootstrap_validate_version_dev(sha, description)
else
renv_bootstrap_validate_version_release(version, description)
if (valid)
return(TRUE)
# the loaded version of renv doesn't match the requested version;
# give the user instructions on how to proceed
dev <- identical(description[["RemoteType"]], "github")
remote <- if (dev)
paste("rstudio/renv", description[["RemoteSha"]], sep = "@")
else
paste("renv", description[["Version"]], sep = "@")
# display both loaded version + sha if available
friendly <- renv_bootstrap_version_friendly(
version = description[["Version"]],
sha     = if (dev) description[["RemoteSha"]]
)
fmt <- heredoc("
renv %1$s was loaded from project library, but this project is configured to use renv %2$s.
- Use `renv::record(\"%3$s\")` to record renv %1$s in the lockfile.
- Use `renv::restore(packages = \"renv\")` to install renv %2$s into the project library.
")
catf(fmt, friendly, renv_bootstrap_version_friendly(version), remote)
FALSE
}
renv_bootstrap_validate_version_dev <- function(version, description) {
expected <- description[["RemoteSha"]]
if (!is.character(expected))
return(FALSE)
pattern <- sprintf("^\\Q%s\\E", version)
grepl(pattern, expected, perl = TRUE)
}
renv_bootstrap_validate_version_release <- function(version, description) {
expected <- description[["Version"]]
is.character(expected) && identical(expected, version)
}
renv_bootstrap_hash_text <- function(text) {
hashfile <- tempfile("renv-hash-")
on.exit(unlink(hashfile), add = TRUE)
writeLines(text, con = hashfile)
tools::md5sum(hashfile)
}
renv_bootstrap_load <- function(project, libpath, version) {
# try to load renv from the project library
if (!requireNamespace("renv", lib.loc = libpath, quietly = TRUE))
return(FALSE)
# warn if the version of renv loaded does not match
renv_bootstrap_validate_version(version)
# execute renv load hooks, if any
hooks <- getHook("renv::autoload")
for (hook in hooks)
if (is.function(hook))
tryCatch(hook(), error = warnify)
# load the project
renv::load(project)
TRUE
}
renv_bootstrap_profile_load <- function(project) {
# if RENV_PROFILE is already set, just use that
profile <- Sys.getenv("RENV_PROFILE", unset = NA)
if (!is.na(profile) && nzchar(profile))
return(profile)
# check for a profile file (nothing to do if it doesn't exist)
path <- renv_bootstrap_paths_renv("profile", profile = FALSE, project = project)
if (!file.exists(path))
return(NULL)
# read the profile, and set it if it exists
contents <- readLines(path, warn = FALSE)
if (length(contents) == 0L)
return(NULL)
# set RENV_PROFILE
profile <- contents[[1L]]
if (!profile %in% c("", "default"))
Sys.setenv(RENV_PROFILE = profile)
profile
}
renv_bootstrap_profile_prefix <- function() {
profile <- renv_bootstrap_profile_get()
if (!is.null(profile))
return(file.path("profiles", profile, "renv"))
}
renv_bootstrap_profile_get <- function() {
profile <- Sys.getenv("RENV_PROFILE", unset = "")
renv_bootstrap_profile_normalize(profile)
}
renv_bootstrap_profile_set <- function(profile) {
profile <- renv_bootstrap_profile_normalize(profile)
if (is.null(profile))
Sys.unsetenv("RENV_PROFILE")
else
Sys.setenv(RENV_PROFILE = profile)
}
renv_bootstrap_profile_normalize <- function(profile) {
if (is.null(profile) || profile %in% c("", "default"))
return(NULL)
profile
}
renv_bootstrap_path_absolute <- function(path) {
substr(path, 1L, 1L) %in% c("~", "/", "\\") || (
substr(path, 1L, 1L) %in% c(letters, LETTERS) &&
substr(path, 2L, 3L) %in% c(":/", ":\\")
)
}
renv_bootstrap_paths_renv <- function(..., profile = TRUE, project = NULL) {
renv <- Sys.getenv("RENV_PATHS_RENV", unset = "renv")
root <- if (renv_bootstrap_path_absolute(renv)) NULL else project
prefix <- if (profile) renv_bootstrap_profile_prefix()
components <- c(root, renv, prefix, ...)
paste(components, collapse = "/")
}
renv_bootstrap_project_type <- function(path) {
descpath <- file.path(path, "DESCRIPTION")
if (!file.exists(descpath))
return("unknown")
desc <- tryCatch(
read.dcf(descpath, all = TRUE),
error = identity
)
if (inherits(desc, "error"))
return("unknown")
type <- desc$Type
if (!is.null(type))
return(tolower(type))
package <- desc$Package
if (!is.null(package))
return("package")
"unknown"
}
renv_bootstrap_user_dir <- function() {
dir <- renv_bootstrap_user_dir_impl()
path.expand(chartr("\\", "/", dir))
}
renv_bootstrap_user_dir_impl <- function() {
# use local override if set
override <- getOption("renv.userdir.override")
if (!is.null(override))
return(override)
# use R_user_dir if available
tools <- asNamespace("tools")
if (is.function(tools$R_user_dir))
return(tools$R_user_dir("renv", "cache"))
# try using our own backfill for older versions of R
envvars <- c("R_USER_CACHE_DIR", "XDG_CACHE_HOME")
for (envvar in envvars) {
root <- Sys.getenv(envvar, unset = NA)
if (!is.na(root))
return(file.path(root, "R/renv"))
}
# use platform-specific default fallbacks
if (Sys.info()[["sysname"]] == "Windows")
file.path(Sys.getenv("LOCALAPPDATA"), "R/cache/R/renv")
else if (Sys.info()[["sysname"]] == "Darwin")
"~/Library/Caches/org.R-project.R/R/renv"
else
"~/.cache/R/renv"
}
renv_bootstrap_version_friendly <- function(version, shafmt = NULL, sha = NULL) {
sha <- sha %||% attr(version, "sha", exact = TRUE)
parts <- c(version, sprintf(shafmt %||% " [sha: %s]", substring(sha, 1L, 7L)))
paste(parts, collapse = "")
}
renv_bootstrap_exec <- function(project, libpath, version) {
if (!renv_bootstrap_load(project, libpath, version))
renv_bootstrap_run(project, libpath, version)
}
renv_bootstrap_run <- function(project, libpath, version) {
# perform bootstrap
bootstrap(version, libpath)
# exit early if we're just testing bootstrap
if (!is.na(Sys.getenv("RENV_BOOTSTRAP_INSTALL_ONLY", unset = NA)))
return(TRUE)
# try again to load
if (requireNamespace("renv", lib.loc = libpath, quietly = TRUE)) {
return(renv::load(project = project))
}
# failed to download or load renv; warn the user
msg <- c(
"Failed to find an renv installation: the project will not be loaded.",
"Use `renv::activate()` to re-initialize the project."
)
warning(paste(msg, collapse = "\n"), call. = FALSE)
}
renv_json_read <- function(file = NULL, text = NULL) {
jlerr <- NULL
# if jsonlite is loaded, use that instead
if ("jsonlite" %in% loadedNamespaces()) {
json <- tryCatch(renv_json_read_jsonlite(file, text), error = identity)
if (!inherits(json, "error"))
return(json)
jlerr <- json
}
# otherwise, fall back to the default JSON reader
json <- tryCatch(renv_json_read_default(file, text), error = identity)
if (!inherits(json, "error"))
return(json)
# report an error
if (!is.null(jlerr))
stop(jlerr)
else
stop(json)
}
renv_json_read_jsonlite <- function(file = NULL, text = NULL) {
text <- paste(text %||% readLines(file, warn = FALSE), collapse = "\n")
jsonlite::fromJSON(txt = text, simplifyVector = FALSE)
}
renv_json_read_patterns <- function() {
list(
# objects
list("{", "\t\n\tobject(\t\n\t", TRUE),
list("}", "\t\n\t)\t\n\t",       TRUE),
# arrays
list("[", "\t\n\tarray(\t\n\t", TRUE),
list("]", "\n\t\n)\n\t\n",      TRUE),
# maps
list(":", "\t\n\t=\t\n\t", TRUE),
# newlines
list("\\u000a", "\n", FALSE)
)
}
renv_json_read_envir <- function() {
envir <- new.env(parent = emptyenv())
envir[["+"]] <- `+`
envir[["-"]] <- `-`
envir[["object"]] <- function(...) {
result <- list(...)
names(result) <- as.character(names(result))
result
}
envir[["array"]] <- list
envir[["true"]]  <- TRUE
envir[["false"]] <- FALSE
envir[["null"]]  <- NULL
envir
}
renv_json_read_remap <- function(object, patterns) {
# repair names if necessary
if (!is.null(names(object))) {
nms <- names(object)
for (pattern in patterns)
nms <- gsub(pattern[[2L]], pattern[[1L]], nms, fixed = TRUE)
names(object) <- nms
}
# repair strings if necessary
if (is.character(object)) {
for (pattern in patterns)
object <- gsub(pattern[[2L]], pattern[[1L]], object, fixed = TRUE)
}
# recurse for other objects
if (is.recursive(object))
for (i in seq_along(object))
object[i] <- list(renv_json_read_remap(object[[i]], patterns))
# return remapped object
object
}
renv_json_read_default <- function(file = NULL, text = NULL) {
# read json text
text <- paste(text %||% readLines(file, warn = FALSE), collapse = "\n")
# convert into something the R parser will understand
patterns <- renv_json_read_patterns()
transformed <- text
for (pattern in patterns)
transformed <- gsub(pattern[[1L]], pattern[[2L]], transformed, fixed = TRUE)
# parse it
rfile <- tempfile("renv-json-", fileext = ".R")
on.exit(unlink(rfile), add = TRUE)
writeLines(transformed, con = rfile)
json <- parse(rfile, keep.source = FALSE, srcfile = NULL)[[1L]]
# evaluate in safe environment
result <- eval(json, envir = renv_json_read_envir())
# fix up strings if necessary -- do so only with reversible patterns
patterns <- Filter(function(pattern) pattern[[3L]], patterns)
renv_json_read_remap(result, patterns)
}
# load the renv profile, if any
renv_bootstrap_profile_load(project)
# construct path to library root
root <- renv_bootstrap_library_root(project)
# construct library prefix for platform
prefix <- renv_bootstrap_platform_prefix()
# construct full libpath
libpath <- file.path(root, prefix)
# run bootstrap code
renv_bootstrap_exec(project, libpath, version)
invisible()
})
renv::install(quarto)
install.packages("quarto")
renv::snapshot()
quarto_preview
# -----------------------------
# Academic Portfolio Setup Script
# -----------------------------
# 1️⃣ Activate or initialize renv
if (!requireNamespace("renv", quietly = TRUE)) {
install.packages("renv", type = "binary")
}
# Activate project-specific library
renv::activate()
# If renv not yet initialized, initialize it
if (!file.exists("renv.lock")) {
renv::init()
} else {
message("renv already initialized. Restoring environment...")
renv::restore()
}
# 4️⃣ Optional: check status
renv::status()
quarto_preview
quarto::quarto_preview()
# -----------------------------
# Academic Portfolio Setup Script
# -----------------------------
# 1️⃣ Activate or initialize renv
if (!requireNamespace("renv", quietly = TRUE)) {
install.packages("renv", type = "binary")
}
# Activate project-specific library
renv::activate()
# If renv not yet initialized, initialize it
if (!file.exists("renv.lock")) {
renv::init()
} else {
message("renv already initialized. Restoring environment...")
renv::restore()
}
# -----------------------------
# Academic Portfolio Setup Script
# -----------------------------
# 1️⃣ Activate or initialize renv
if (!requireNamespace("renv", quietly = TRUE)) {
install.packages("renv", type = "binary")
}
# Activate project-specific library
renv::activate()
# If renv not yet initialized, initialize it
if (!file.exists("renv.lock")) {
renv::init()
} else {
message("renv already initialized. Restoring environment...")
renv::restore()
}
quarto::quarto_preview()
quarto::quarto_preview()
quarto::quarto_version()
rlang::last_trace()
rlang::last_trace(drop = FALSE)
rlang::last_trace(drop = FALSE)
rlang::last_trace(drop = FALSE)
quarto::quarto_preview()
quarto_preview()
quarto_preview
quarto::quarto_preview()
rlang::last_trace()
rlang::last_trace(drop = FALSE)
renv::status()
renv::restore()
renv::install()
renv::dependencies()
renv::repair()
renv::refresh()
renv::diagnostics()
renv::repair()
install.packages("brand")
# install.packages("pak")
pak::pak("posit-dev/brand-yml/pkg-r")
install.packages(
'brand.yml',
repos = c('https://posit-dev.r-universe.dev', 'https://cloud.r-project.org')
)
library(brand)
library(brand.yml)
install.packages("froggeR")
632.76 + 2.25 + 10.67 + 1.03
1826.03 + 3373.49
1738.25 + 1738.25 + 2080.55 + 1738.25 + 1772.99 + 1992.89
+ 11160.18 + 5199.52
install.packages("openssl")
install.packages("openssl")
install.packages("miniUI")
library(rmarkdown)
library(fontawesome)
library(knitr)
library(quarto)
library(renv)
